"""Trade service for trade execution business logic."""

import logging
from typing import Dict, List, Optional, Any

from backend.db.pitch_db import find_pitch_by_id
from backend.db.execution_db import log_execution_event
from backend.multi_alpaca_client import MultiAlpacaManager
from backend.alpaca_integration.orders import create_bracket_order_from_pitch

logger = logging.getLogger(__name__)


class TradeService:
    """
    Service class for trade execution operations.

    Provides business logic for trade execution and management including:
    - Pending trades retrieval from pipeline state
    - Trade execution using bracket orders via Alpaca
    - Integration with MultiAlpacaManager for multi-account trading
    - Per-trade error handling and status tracking

    This service acts as a bridge between API routes and trading operations,
    encapsulating business logic for trade execution and account management.
    """

    def __init__(self):
        """Initialize the TradeService."""
        pass

    def get_pending_trades(self, pipeline_state: Any = None) -> List[Dict[str, Any]]:
        """
        Get pending trades from pipeline state.

        Retrieves the list of pending trades that are waiting to be executed.
        These trades are typically generated by the council synthesis process.

        Args:
            pipeline_state: Global pipeline state object

        Returns:
            List of pending trade dictionaries. Each dict contains:
                - id: Trade identifier
                - account: Account name (e.g., 'COUNCIL', 'CHATGPT')
                - symbol: Trading instrument
                - direction: Trade direction ('BUY' or 'SELL')
                - qty: Quantity of shares
                - status: Trade status ('pending')
                - conviction: Conviction score
            Returns empty list if no pending trades or error occurs.
        """
        try:
            if pipeline_state and hasattr(pipeline_state, 'pending_trades'):
                trades = pipeline_state.pending_trades
                if trades:
                    logger.info(f"Retrieved {len(trades)} pending trades from pipeline state")
                    return trades
                else:
                    logger.info("No pending trades available in pipeline state")
                    return []
            else:
                logger.warning("Pipeline state not available or has no pending_trades attribute")
                return []

        except Exception as e:
            logger.error(f"Error in get_pending_trades: {e}", exc_info=True)
            return []

    async def execute_trades(
        self,
        trade_ids: List[int],
        pipeline_state: Any = None
    ) -> Dict[str, Any]:
        """
        Execute trades using bracket orders.

        Executes a list of trades by retrieving pitch data from the database,
        creating bracket orders (main + take profit + stop loss), and submitting
        them to Alpaca for each specified account.

        Args:
            trade_ids: List of trade IDs (pitch database IDs) to execute
            pipeline_state: Global pipeline state object for status tracking

        Returns:
            Dict containing:
                - status: Overall status ('success' or 'error')
                - message: Summary message
                - results: List of per-trade results with:
                    - trade_id: Trade identifier
                    - status: 'submitted', 'error', or 'skipped'
                    - order_id: Alpaca order ID (if submitted)
                    - symbol: Trading instrument (if submitted)
                    - side: Order side 'buy' or 'sell' (if submitted)
                    - qty: Quantity of shares (if submitted)
                    - limit_price: Limit price (if submitted)
                    - take_profit_price: Take profit price (if submitted)
                    - stop_loss_price: Stop loss price (if submitted)
                    - message: Status message

        Raises:
            Exception: If there's a critical error in trade execution

        Database Tables:
            - pm_pitches: Contains PM pitch data with entry/exit policies

        Notes:
            - FLAT positions are automatically skipped
            - Each trade is executed independently with its own error handling
            - Failed trades don't prevent other trades from executing
            - Pipeline state is updated with executed trades
            - Pending trades are cleaned up after execution
        """
        try:
            manager = MultiAlpacaManager()
            results = []

            if not trade_ids:
                logger.info("No trade IDs provided for execution")
                return {
                    "status": "success",
                    "message": "No trades to execute",
                    "results": [],
                }

            logger.info(f"Executing {len(trade_ids)} trade(s)")

            for trade_id in trade_ids:
                # Find pitch from database
                pitch = await find_pitch_by_id(trade_id)

                if not pitch:
                    logger.warning(f"Pitch {trade_id} not found in database")
                    results.append(
                        {
                            "trade_id": trade_id,
                            "status": "error",
                            "message": "Pitch not found in database",
                        }
                    )
                    continue

                # Skip FLAT positions
                if pitch.get("direction") == "FLAT":
                    logger.info(f"Skipping FLAT position for trade {trade_id}")
                    results.append(
                        {
                            "trade_id": trade_id,
                            "status": "skipped",
                            "message": "FLAT position - no trade executed",
                        }
                    )
                    continue

                # Get account name from pitch
                account_name = pitch.get("account", "COUNCIL")
                logger.info(f"Executing trade {trade_id} for account {account_name}")

                # Get Alpaca client for this account
                alpaca_account = manager.clients.get(account_name)

                if not alpaca_account:
                    logger.error(
                        f"Account {account_name} not initialized or missing credentials"
                    )
                    results.append(
                        {
                            "trade_id": trade_id,
                            "status": "error",
                            "message": f"Account {account_name} not initialized or missing credentials",
                        }
                    )
                    continue

                try:
                    # Create bracket order
                    order_result = create_bracket_order_from_pitch(
                        alpaca_account, pitch
                    )

                    if order_result:
                        logger.info(
                            f"Bracket order submitted for trade {trade_id}: "
                            f"order_id={order_result.get('order_id')}, "
                            f"symbol={order_result.get('symbol')}, "
                            f"side={order_result.get('side')}, "
                            f"qty={order_result.get('qty')}"
                        )

                        # Log order_placed event
                        week_id = pitch.get("week_id", "unknown")
                        await log_execution_event(
                            week_id=week_id,
                            event_type="order_placed",
                            account=account_name,
                            event_data={
                                "trade_id": trade_id,
                                "symbol": order_result.get("symbol"),
                                "side": order_result.get("side"),
                                "qty": order_result.get("qty"),
                                "order_id": order_result.get("order_id"),
                                "limit_price": order_result.get("limit_price"),
                                "take_profit_price": order_result.get("take_profit_price"),
                                "stop_loss_price": order_result.get("stop_loss_price"),
                            }
                        )

                        results.append(
                            {
                                "trade_id": trade_id,
                                "status": "submitted",
                                "order_id": order_result.get("order_id"),
                                "symbol": order_result.get("symbol"),
                                "side": order_result.get("side"),
                                "qty": order_result.get("qty"),
                                "limit_price": order_result.get("limit_price"),
                                "take_profit_price": order_result.get(
                                    "take_profit_price"
                                ),
                                "stop_loss_price": order_result.get("stop_loss_price"),
                                "message": f"Bracket order submitted for {account_name}",
                            }
                        )

                        # Update pipeline state
                        if pipeline_state and hasattr(pipeline_state, 'pending_trades'):
                            for trade in pipeline_state.pending_trades:
                                if trade.get("id") == trade_id:
                                    trade["status"] = "filled"
                                    trade["order_id"] = order_result.get("order_id")

                                    # Add to executed trades
                                    if not hasattr(pipeline_state, 'executed_trades'):
                                        pipeline_state.executed_trades = []
                                    pipeline_state.executed_trades.append(trade)
                                    break
                    else:
                        logger.error(f"Failed to create bracket order for trade {trade_id}")

                        # Log order_failed event
                        week_id = pitch.get("week_id", "unknown")
                        await log_execution_event(
                            week_id=week_id,
                            event_type="order_failed",
                            account=account_name,
                            event_data={
                                "trade_id": trade_id,
                                "symbol": pitch.get("symbol"),
                                "direction": pitch.get("direction"),
                                "error": "Failed to create bracket order",
                            }
                        )

                        results.append(
                            {
                                "trade_id": trade_id,
                                "status": "error",
                                "message": "Failed to create bracket order",
                            }
                        )

                except Exception as e:
                    logger.error(
                        f"Order submission failed for trade {trade_id}: {e}",
                        exc_info=True,
                    )

                    # Log order_failed event
                    week_id = pitch.get("week_id", "unknown")
                    await log_execution_event(
                        week_id=week_id,
                        event_type="order_failed",
                        account=account_name,
                        event_data={
                            "trade_id": trade_id,
                            "symbol": pitch.get("symbol"),
                            "direction": pitch.get("direction"),
                            "error": str(e),
                            "error_type": type(e).__name__,
                        }
                    )

                    results.append(
                        {
                            "trade_id": trade_id,
                            "status": "error",
                            "message": f"Order submission failed: {str(e)}",
                        }
                    )

            # Clean up pending trades - keep only those still pending
            if pipeline_state and hasattr(pipeline_state, 'pending_trades'):
                pipeline_state.pending_trades = [
                    t
                    for t in pipeline_state.pending_trades
                    if t.get("status") == "pending"
                ]
                logger.info(
                    f"Cleaned up pending trades. "
                    f"Remaining pending: {len(pipeline_state.pending_trades)}"
                )

            success_count = sum(1 for r in results if r["status"] == "submitted")
            error_count = sum(1 for r in results if r["status"] == "error")
            skipped_count = sum(1 for r in results if r["status"] == "skipped")

            logger.info(
                f"Trade execution complete: {success_count} submitted, "
                f"{error_count} errors, {skipped_count} skipped"
            )

            return {
                "status": "success",
                "message": f"Processed {len(trade_ids)} trade(s): {success_count} submitted, {error_count} errors, {skipped_count} skipped",
                "results": results,
            }

        except Exception as e:
            logger.error(f"Critical error in execute_trades: {e}", exc_info=True)
            raise

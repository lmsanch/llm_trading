"""Trade execution API endpoints."""

import logging
from typing import Dict, Any, List

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, Field

from backend.services.trade_service import TradeService

logger = logging.getLogger(__name__)

# Create router for trade endpoints
router = APIRouter(prefix="/api/trades", tags=["trades"])

# Initialize trade service
trade_service = TradeService()


class ExecuteTradesRequest(BaseModel):
    """Request model for trade execution."""

    trade_ids: List[int] = Field(
        ...,
        description="List of trade IDs (pitch database IDs) to execute",
    )


# Global pipeline state (will be injected or imported in Phase 5)
# For now, we'll access it from backend.main
def get_pipeline_state():
    """
    Get the global pipeline state.

    This is a temporary workaround until Phase 5 when we create
    proper dependency injection with backend/dependencies.py.

    Returns:
        Pipeline state object from backend.main
    """
    try:
        from backend.main import pipeline_state

        return pipeline_state
    except ImportError:
        logger.warning("Could not import pipeline_state from backend.main")
        return None


@router.get("/pending")
async def get_pending_trades() -> List[Dict[str, Any]]:
    """
    Get pending trades from pipeline state.

    Retrieves the list of pending trades that are waiting to be executed.
    These trades are typically generated by the council synthesis process
    and are ready for execution via the /execute endpoint.

    Returns:
        List of pending trade dictionaries. Each dict contains:
            - id: Trade identifier (pitch database ID)
            - account: Account name (e.g., 'COUNCIL', 'CHATGPT')
            - symbol: Trading instrument (e.g., 'SPY', 'TLT')
            - direction: Trade direction ('BUY' or 'SELL')
            - qty: Quantity of shares
            - status: Trade status ('pending')
            - conviction: Conviction score (0.0 to 1.0)
            - entry_price: Proposed entry price (optional)
            - target_price: Target price for take profit (optional)
            - stop_price: Stop loss price (optional)
        Returns empty list if no pending trades found.

    Example Response:
        [
            {
                "id": 42,
                "account": "COUNCIL",
                "symbol": "SPY",
                "direction": "BUY",
                "qty": 100,
                "status": "pending",
                "conviction": 0.82,
                "entry_price": 471.20,
                "target_price": 485.00,
                "stop_price": 465.00
            }
        ]
    """
    try:
        pipeline_state = get_pipeline_state()

        if not pipeline_state:
            logger.warning("Pipeline state not available, returning empty list")
            return []

        # Get pending trades from service
        pending_trades = trade_service.get_pending_trades(pipeline_state)

        logger.info(f"Retrieved {len(pending_trades)} pending trades")
        return pending_trades

    except Exception as e:
        logger.error(f"Error in get_pending_trades endpoint: {e}", exc_info=True)
        # Return empty list on error (don't raise, so frontend doesn't break)
        return []


@router.post("/execute")
async def execute_trades(request: ExecuteTradesRequest) -> Dict[str, Any]:
    """
    Execute trades using bracket orders.

    Executes a list of trades by retrieving pitch data from the database,
    creating bracket orders (main + take profit + stop loss), and submitting
    them to Alpaca for each specified account.

    This endpoint handles trade execution with per-trade error handling,
    meaning that if one trade fails, other trades in the list will still
    be attempted.

    Args:
        request: Request body with trade_ids list

    Returns:
        Dict containing:
            - status: Overall status ('success' or 'error')
            - message: Summary message with counts
            - results: List of per-trade results with:
                - trade_id: Trade identifier (pitch database ID)
                - status: 'submitted', 'error', or 'skipped'
                - order_id: Alpaca order ID (if submitted)
                - symbol: Trading instrument (if submitted)
                - side: Order side 'buy' or 'sell' (if submitted)
                - qty: Quantity of shares (if submitted)
                - limit_price: Entry limit price (if submitted)
                - take_profit_price: Take profit price (if submitted)
                - stop_loss_price: Stop loss price (if submitted)
                - message: Status or error message

    Raises:
        HTTPException: 500 if pipeline state is not available
        HTTPException: 400 if trade_ids list is empty
        HTTPException: 500 if there's a critical error in trade execution

    Database Tables:
        - pm_pitches: Contains PM pitch data with entry/exit policies

    Example Request:
        {
            "trade_ids": [42, 43]
        }

    Example Response:
        {
            "status": "success",
            "message": "Processed 2 trade(s): 2 submitted, 0 errors, 0 skipped",
            "results": [
                {
                    "trade_id": 42,
                    "status": "submitted",
                    "order_id": "abc123",
                    "symbol": "SPY",
                    "side": "buy",
                    "qty": 100,
                    "limit_price": 471.20,
                    "take_profit_price": 485.00,
                    "stop_loss_price": 465.00,
                    "message": "Bracket order submitted for COUNCIL"
                },
                {
                    "trade_id": 43,
                    "status": "skipped",
                    "message": "FLAT position - no trade executed"
                }
            ]
        }

    Notes:
        - FLAT positions are automatically skipped
        - Each trade is executed independently with its own error handling
        - Failed trades don't prevent other trades from executing
        - Pipeline state is updated with executed trades
        - Pending trades are cleaned up after execution
    """
    try:
        pipeline_state = get_pipeline_state()

        if not pipeline_state:
            logger.error("Pipeline state not available")
            raise HTTPException(
                status_code=500, detail="Pipeline state not available"
            )

        if not request.trade_ids:
            logger.warning("Empty trade_ids list provided")
            raise HTTPException(
                status_code=400, detail="trade_ids list cannot be empty"
            )

        logger.info(f"Executing {len(request.trade_ids)} trade(s)")

        # Execute trades via service
        result = await trade_service.execute_trades(
            trade_ids=request.trade_ids,
            pipeline_state=pipeline_state,
        )

        # Log summary
        success_count = sum(1 for r in result["results"] if r["status"] == "submitted")
        error_count = sum(1 for r in result["results"] if r["status"] == "error")
        skipped_count = sum(1 for r in result["results"] if r["status"] == "skipped")

        logger.info(
            f"Trade execution complete: {success_count} submitted, "
            f"{error_count} errors, {skipped_count} skipped"
        )

        return result

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error in execute_trades endpoint: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))
